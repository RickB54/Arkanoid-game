<!DOCTYPE html>
<html>
<head>
    <title>Web Arkanoid</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
            touch-action: none;  /* Disable browser touch interactions */
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 4/3;  /* Standard game aspect ratio */
            object-fit: contain;
        }

        /* Landscape mode adjustments */
        @media screen and (orientation: landscape) {
            body {
                flex-direction: row;
            }

            #gameContainer {
                width: 100%;
                height: 100%;
                max-height: 100vh;
            }

            #gameCanvas {
                max-width: 100%;
                max-height: 100%;
                width: auto;
                height: 100%;
            }
        }

        /* Ensure HUD elements are visible and scaled */
        .hud {
            position: absolute;
            color: white;
            font-size: 16px;
            z-index: 10;
        }

        #score { top: 10px; left: 10px; }
        #lives { top: 10px; right: 10px; }
        #level { top: 10px; left: 50%; transform: translateX(-50%); }
        #pauseButton, #settingsButton {
            position: absolute;
            bottom: 10px;
            color: white;
            background: rgba(255,255,255,0.2);
            border: none;
            padding: 10px;
            z-index: 10;
        }
        #pauseButton { left: 10px; }
        #settingsButton { right: 10px; }

        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            text-align: center;
            opacity: 0.7;
        }
        .particle {
            position: absolute;
            pointer-events: none;
            animation: particle 0.5s ease-out forwards;
        }
        @keyframes particle {
            0% { transform: translate(0, 0); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)); opacity: 0; }
        }
        @media (max-width: 600px) {
            #instructions { font-size: 14px; bottom: 10px; }
            .hud { font-size: 16px; }
        }
        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            color: white;
            display: none;
        }
        #gameOverScreen button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
        }
        .menu-button {
            font-family: Arial, sans-serif;
            background: #4CAF50;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: block;
            width: 100%;
            font-size: 16px;
            margin: 8px 0;
            cursor: pointer;
            border-radius: 4px;
        }

        .menu-button:hover {
            background: #45a049;
        }

        #settingsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            display: none;
            z-index: 1001;
            min-width: 300px;
        }

        #rulesContent {
            display: none;
            margin-top: 10px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .level-select {
            background: #4CAF50;
            color: white;
            padding: 5px;
            border: none;
            border-radius: 4px;
            margin-top: 10px;
            width: 100%;
        }

        #rulesModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            color: white;
            z-index: 1000;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }

        #rulesModal ul {
            list-style: none;
            padding: 0;
            margin: 15px 0;
        }

        #rulesModal li {
            margin: 12px 0;
            line-height: 1.4;
            display: flex;
            align-items: center;
            padding: 0;
        }

        #rulesModal li:before {
            display: none;  /* Remove any pseudo-elements */
        }

        #rulesModal .power-up-example {
            display: inline-flex;
            width: 24px;
            height: 24px;
            border: 1px solid white;
            border-radius: 4px;
            margin-right: 12px;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
            flex-shrink: 0;
            position: relative;
        }

        #rulesModal .close-btn, #rulesModal .back-btn {
            background: none;
            border: 2px solid #4CAF50;
            color: #4CAF50;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        #rulesModal .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }

        #rulesModal .close-btn:hover {
            color: #4CAF50;
        }

        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <audio id="paddleHitSound" src="sounds/paddle-hit.mp3" preload="auto"></audio>
        <audio id="blockBreakSound" src="sounds/block-break.mp3" preload="auto"></audio>
        <audio id="lifeGainSound" src="sounds/life-gain.mp3" preload="auto"></audio>
        <audio id="lifeLossSound" src="sounds/life-loss.mp3" preload="auto"></audio>
        <div id="score" class="hud">Score: 0</div>
        <div id="lives" class="hud">Lives: 3</div>
        <div id="level" class="hud">Level: 1</div>
        <button id="pauseButton">Start</button>
        <button id="settingsButton">Settings</button>
        <div id="instructions">
            Desktop: Use ← → arrow keys<br>
            Mobile: Tap sides, swipe, or drag paddle
        </div>
        <div id="gameOverScreen">
            <h2 id="gameOverTitle">Game Over</h2>
            <p id="gameOverScore">Score: 0</p>
            <button onclick="restartGame()">Play Again</button>
        </div>
        <div id="settingsMenu" class="menu">
            <h2>Settings</h2>
            <button class="menu-button" onclick="showRules()">Rules of the Game</button>
            <select id="levelSelect" class="level-select">
                <option value="">Skip to Level...</option>
                <option value="1">Level 1</option>
                <option value="2">Level 2</option>
                <option value="3">Level 3</option>
                <option value="4">Level 4</option>
                <option value="5">Level 5</option>
                <option value="6">Level 6</option>
                <option value="7">Level 7</option>
                <option value="8">Level 8</option>
            </select>
            <button class="menu-button" onclick="endGame()">End Game</button>
            <button class="menu-button" onclick="closeSettings()">Close</button>
        </div>
    </div>
    <div class="modal-overlay" id="modalOverlay"></div>
    <div id="rulesModal">
        <button class="back-btn" onclick="backToSettings()">Back</button>
        <button class="close-btn" onclick="closeRules()">X</button>
        <h2>Arkanoid Game Rules</h2>
        
        <h3>Basic Gameplay</h3>
        <ul>
            <li>Move the paddle left and right to bounce the ball</li>
            <li>Break all blocks to complete each level</li>
            <li>Don't let the ball fall below the paddle</li>
            <li>You start with 3 lives</li>
            <li>Higher levels increase ball speed by 20% each time</li>
        </ul>

        <h3>Block Types</h3>
        <ul>
            <li><span class="power-up-example" style="background: #4CAF50;"></span>Green blocks: Single-hit blocks</li>
            <li><span class="power-up-example" style="background: #FFA500;"></span>Orange blocks: Double-hit blocks</li>
            <li><span class="power-up-example" style="background: #FF4136;"></span>Red blocks: Triple-hit blocks</li>
            <li><span class="power-up-example" style="background: #FF0000;"></span>Skull blocks: Dangerous life-draining blocks</li>
        </ul>

        <h3>Power-ups</h3>
        <ul>
            <li><span class="power-up-example" style="background: #4169E1;"></span>Blue plus: Increases paddle size by 50%</li>
            <li><span class="power-up-example" style="background: #FF4136;"></span>Red minus: Decreases paddle size by 30%</li>
            <li><span class="power-up-example" style="background: #4CAF50;"></span>Green heart: Gain an extra life</li>
            <li><span class="power-up-example" style="background: #FF0000;"></span>Red skull: Lose one life - watch out!</li>
        </ul>

        <h3>Scoring System</h3>
        <ul>
            <li>Green blocks: 10 points</li>
            <li>Orange blocks: 20 points</li>
            <li>Red blocks: 30 points</li>
            <li>Complete a level: Bonus points!</li>
        </ul>

        <h3>Game Controls</h3>
        <ul>
            <li>Left Arrow or A: Move paddle left</li>
            <li>Right Arrow or D: Move paddle right</li>
            <li>P or ESC: Pause game</li>
            <li>Space: Launch ball / Start game</li>
        </ul>

        <h3>Pro Tips</h3>
        <ul>
            <li>Hit the ball with paddle edges for angle shots</li>
            <li>Avoid the red skull blocks when possible</li>
            <li>Extra lives appear more often after level 5</li>
            <li>Paddle speed increases to match faster levels</li>
        </ul>
    </div>
    <script>
        console.log('Script is loading...');
        window.onerror = function(message, source, lineno, colno, error) {
            console.error('Global error:', {
                message: message,
                source: source,
                lineno: lineno,
                colno: colno,
                error: error
            });
            return false;
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const livesElement = document.getElementById('lives');
        const levelElement = document.getElementById('level');
        const pauseButton = document.getElementById('pauseButton');

        // Game state
        let gameState = {
            level: 1,
            score: 0,
            lives: 3,
            paused: false,
            gameStarted: false,
            gameOver: false
        };

        // Game constants
        const PADDLE_HEIGHT = 10;
        const BALL_SIZE = 6;
        const BLOCK_WIDTH = 60;
        const BLOCK_HEIGHT = 15;

        // Level configurations with more challenging patterns
        const LEVELS = [
            {
                pattern: [  // Level 1: Basic with gaps
                    [1,1,0,1,1,0,1,1],
                    [1,0,1,1,1,1,0,1],
                    [1,1,1,0,0,1,1,1]
                ],
                ballSpeed: 3,      // Base speed
                paddleWidth: 100
            },
            {
                pattern: [  // Level 2: Zigzag path
                    [1,2,0,0,0,0,2,1],
                    [0,1,2,0,0,2,1,0],
                    [0,0,1,2,2,1,0,0],
                    [0,1,2,0,0,2,1,0],
                    [1,2,0,0,0,0,2,1]
                ],
                ballSpeed: 3.6,    // +20%
                paddleWidth: 95
            },
            {
                pattern: [  // Level 3: Tunnel challenge
                    [2,2,2,0,0,2,2,2],
                    [2,0,0,0,0,0,0,2],
                    [2,0,1,1,1,1,0,2],
                    [2,0,0,0,0,0,0,2],
                    [2,2,2,0,0,2,2,2]
                ],
                ballSpeed: 4.32,   // +20%
                paddleWidth: 90
            },
            {
                pattern: [  // Level 4: Scattered fortress
                    [3,0,2,3,3,2,0,3],
                    [0,2,0,3,3,0,2,0],
                    [2,0,2,0,0,2,0,2],
                    [3,3,0,0,0,0,3,3],
                    [0,2,0,3,3,0,2,0]
                ],
                ballSpeed: 5.18,   // +20%
                paddleWidth: 85
            },
            {
                pattern: [  // Level 5: Maze with tough blocks
                    [3,3,3,0,0,3,3,3],
                    [0,0,3,3,3,3,0,0],
                    [3,0,2,0,0,2,0,3],
                    [3,3,0,0,0,0,3,3],
                    [0,3,2,3,3,2,3,0],
                    [3,0,3,3,3,3,0,3]
                ],
                ballSpeed: 6.22,   // +20%
                paddleWidth: 85
            },
            {
                pattern: [  // Level 6: Sniper's challenge
                    [0,3,0,3,3,0,3,0],
                    [3,0,2,0,0,2,0,3],
                    [0,2,0,3,3,0,2,0],
                    [3,0,3,0,0,3,0,3],
                    [0,2,0,3,3,0,2,0]
                ],
                ballSpeed: 7.46,   // +20%
                paddleWidth: 80
            },
            {
                pattern: [  // Level 7: Gauntlet
                    [3,0,3,0,0,3,0,3],
                    [0,2,0,3,3,0,2,0],
                    [0,0,1,2,2,1,0,0],
                    [0,1,2,0,0,2,1,0],
                    [3,0,3,2,2,3,0,3],
                    [0,2,0,3,3,0,2,0]
                ],
                ballSpeed: 8.95,   // +20%
                paddleWidth: 80
            },
            {
                pattern: [  // Level 8: Ultimate Challenge
                    [3,0,3,2,2,3,0,3],
                    [0,3,0,3,3,0,3,0],
                    [2,0,3,0,0,3,0,2],
                    [3,2,0,3,3,0,2,3],
                    [0,3,2,0,0,2,3,0],
                    [3,0,3,2,2,3,0,3]
                ],
                ballSpeed: 10.74,  // +20%
                paddleWidth: 75
            }
        ];

        // Colors with gradients
        const COLORS = [
            ['#ff0000', '#ff6666'],  // Red
            ['#00ff00', '#66ff66'],  // Green
            ['#0000ff', '#6666ff'],  // Blue
            ['#ffff00', '#ffff66'],  // Yellow
            ['#ff00ff', '#ff66ff']   // Magenta
        ];

        // Game objects
        let paddle = {
            x: canvas.width / 2,
            y: canvas.height - 30,
            width: LEVELS[0].paddleWidth,
            height: PADDLE_HEIGHT,
            speed: 6
        };

        let ball = {
            x: canvas.width / 2,
            y: canvas.height - 40,
            size: BALL_SIZE,
            speedX: 0,
            speedY: 0,
            initialSpeedX: LEVELS[0].ballSpeed * (Math.random() > 0.5 ? 1 : -1),
            initialSpeedY: -LEVELS[0].ballSpeed
        };

        let blocks = [];
        let particles = [];
        let touchX = null;
        let isDragging = false;

        // Power-up system
        let powerUps = [];
        const POWERUP_SPEED = 2;
        const POWERUP_SIZE = 15;
        const POWERUP_CHANCE = 0.2;  // 20% chance for power-up on block break
        const EXTRA_LIFE_CHANCE = 0.15;  // 15% chance for extra life in higher levels
        const DRAIN_LIFE_BLOCKS = 1;  // One life-draining block per level (from level 2)

        function createPowerUp(x, y, forcedType = null) {
            if (forcedType || Math.random() < POWERUP_CHANCE) {
                let type;
                if (forcedType) {
                    type = forcedType;
                } else {
                    // In higher levels (5+), chance for extra life
                    if (gameState.level >= 5 && Math.random() < EXTRA_LIFE_CHANCE) {
                        type = 'extraLife';
                    } else {
                        type = Math.random() < 0.5 ? 'shrink' : 'expand';
                    }
                }
                powerUps.push({
                    x: x,
                    y: y,
                    type: type,
                    width: POWERUP_SIZE,
                    height: POWERUP_SIZE,
                    speed: POWERUP_SPEED
                });
            }
        }

        function updatePowerUps() {
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                powerUp.y += powerUp.speed;

                // Check for paddle collision
                if (powerUp.y + powerUp.height >= paddle.y &&
                    powerUp.y <= paddle.y + paddle.height &&
                    powerUp.x + powerUp.width >= paddle.x - paddle.width/2 &&
                    powerUp.x <= paddle.x + paddle.width/2) {
                    
                    // Apply power-up effect
                    switch(powerUp.type) {
                        case 'expand':
                            paddle.width = Math.min(paddle.width * 1.5, canvas.width/2);
                            break;
                        case 'shrink':
                            paddle.width = Math.max(paddle.width * 0.7, 40);
                            break;
                        case 'extraLife':
                            gameState.lives++;
                            livesElement.textContent = `Lives: ${gameState.lives}`;
                            // Visual feedback for extra life
                            livesElement.style.color = '#4CAF50';
                            setTimeout(() => livesElement.style.color = '', 500);
                            break;
                        case 'drainLife':
                            if (gameState.lives > 1) {  // Don't drain last life
                                gameState.lives--;
                                livesElement.textContent = `Lives: ${gameState.lives}`;
                                // Visual feedback for life loss
                                livesElement.style.color = '#FF4136';
                                setTimeout(() => livesElement.style.color = '', 500);
                            }
                            break;
                    }

                    // Remove collected power-up
                    powerUps.splice(i, 1);
                }
                // Remove power-ups that fall off screen
                else if (powerUp.y > canvas.height) {
                    powerUps.splice(i, 1);
                }
            }
        }

        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                ctx.beginPath();
                switch(powerUp.type) {
                    case 'expand':
                        ctx.fillStyle = '#4169E1';  // Royal Blue
                        // Draw plus symbol
                        ctx.fillRect(powerUp.x + 2, powerUp.y + powerUp.height/2 - 2, powerUp.width - 4, 4);
                        ctx.fillRect(powerUp.x + powerUp.width/2 - 2, powerUp.y + 2, 4, powerUp.height - 4);
                        break;
                    case 'shrink':
                        ctx.fillStyle = '#FF4136';  // Red
                        // Draw minus symbol
                        ctx.fillRect(powerUp.x + 2, powerUp.y + powerUp.height/2 - 2, powerUp.width - 4, 4);
                        break;
                    case 'extraLife':
                        ctx.fillStyle = '#4CAF50';  // Green
                        // Draw heart symbol
                        const centerX = powerUp.x + powerUp.width/2;
                        const centerY = powerUp.y + powerUp.height/2;
                        ctx.moveTo(centerX, centerY + 4);
                        ctx.arc(centerX - 2, centerY, 2, 0, Math.PI, true);
                        ctx.arc(centerX + 2, centerY, 2, 0, Math.PI, true);
                        ctx.lineTo(centerX, centerY + 4);
                        break;
                    case 'drainLife':
                        ctx.fillStyle = '#FF0000';  // Bright Red
                        // Draw skull symbol (simplified)
                        ctx.arc(powerUp.x + powerUp.width/2, powerUp.y + powerUp.height/2, 5, 0, Math.PI * 2);
                        ctx.fillRect(powerUp.x + 5, powerUp.y + powerUp.height - 6, powerUp.width - 10, 3);
                        break;
                }
                ctx.strokeStyle = 'white';
                ctx.strokeRect(powerUp.x, powerUp.y, powerUp.width, powerUp.height);
                ctx.fill();
                ctx.stroke();
            });
        }

        // Modified block creation to include life-draining blocks
        function createBlocks() {
            // Clear existing blocks
            blocks = [];
            
            // Get current level configuration
            const currentLevel = LEVELS[gameState.level - 1];
            console.log('Creating blocks for level:', gameState.level);
            console.log('Level pattern:', currentLevel.pattern);
            
            // Validate pattern
            if (!currentLevel.pattern || !Array.isArray(currentLevel.pattern)) {
                console.error('Invalid block pattern for level:', gameState.level);
                return;
            }
            
            // Calculate block positioning
            const rows = currentLevel.pattern;
            const blockWidth = BLOCK_WIDTH;
            const blockHeight = BLOCK_HEIGHT;
            const padding = 10;
            const offsetX = (canvas.width - (rows[0].length * (blockWidth + padding))) / 2;
            const offsetY = 50;
            
            // Create blocks based on pattern
            rows.forEach((row, rowIndex) => {
                row.forEach((blockType, colIndex) => {
                    if (blockType > 0) {
                        blocks.push({
                            x: offsetX + colIndex * (blockWidth + padding),
                            y: offsetY + rowIndex * (blockHeight + padding),
                            width: blockWidth,
                            height: blockHeight,
                            type: blockType,
                            hits: blockType === 3 ? 3 : 1
                        });
                    }
                });
            });
            
            console.log('Total blocks created:', blocks.length);
        }

        // Modified block collision to handle life-draining blocks
        function handleBlockCollision(block, index) {
            block.hits--;
            if (block.hits <= 0) {
                blocks.splice(index, 1);
                gameState.score += 10 * block.type;
                scoreElement.textContent = `Score: ${gameState.score}`;
                
                // Create particles at block position
                createParticles(block.x + block.width/2, block.y + block.height/2);
                
                // Create power-up
                if (block.type === 3) {
                    createPowerUp(block.x + block.width/2, block.y + block.height/2, 'drainLife');
                } else {
                    createPowerUp(block.x + block.width/2, block.y + block.height/2);
                }
            }
        }

        // Modified block drawing to show life-draining blocks
        function drawBlocks() {
            console.log('Drawing blocks:', blocks.length);
            blocks.forEach((block, index) => {
                // Determine block color based on type
                let fillColor;
                switch(block.type) {
                    case 1: fillColor = COLORS[0][0]; break;  // Red
                    case 2: fillColor = COLORS[1][0]; break;  // Green
                    case 3: fillColor = COLORS[2][0]; break;  // Blue
                    default: fillColor = COLORS[0][0];
                }
                
                ctx.fillStyle = fillColor;
                ctx.fillRect(block.x, block.y, block.width, block.height);
                
                // Optional: add block hit points visualization
                ctx.strokeStyle = 'white';
                ctx.strokeRect(block.x, block.y, block.width, block.height);
            });
        }

        // Create particle effect
        function createParticles(x, y) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    speedX: (Math.random() - 0.5) * 4,
                    speedY: (Math.random() - 0.5) * 4,
                    radius: Math.random() * 3 + 1,
                    life: 1
                });
            }
        }

        // Update particles
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.speedX;
                particle.y += particle.speedY;
                particle.life -= 0.02;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        // Draw particles
        function drawParticles() {
            particles.forEach(particle => {
                ctx.beginPath();
                ctx.fillStyle = `rgba(255, 255, 255, ${particle.life})`;
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // Input state
        let keys = {
            left: false,
            right: false
        };

        // Maintain aspect ratio
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const canvas = document.getElementById('gameCanvas');
            
            // Get container dimensions
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            // Calculate the best size maintaining 4:3 aspect ratio
            let newWidth, newHeight;
            
            // Check if we're in landscape mode
            const isLandscape = window.innerWidth > window.innerHeight;
            
            if (isLandscape) {
                // In landscape, fit height and adjust width
                newHeight = containerHeight;
                newWidth = newHeight * (4/3);
                
                // If width exceeds container, adjust
                if (newWidth > containerWidth) {
                    newWidth = containerWidth;
                    newHeight = newWidth * (3/4);
                }
            } else {
                // In portrait, fit width and adjust height
                newWidth = containerWidth;
                newHeight = newWidth * (3/4);
                
                // If height exceeds container, adjust
                if (newHeight > containerHeight) {
                    newHeight = containerHeight;
                    newWidth = newHeight * (4/3);
                }
            }
            
            // Set canvas size
            canvas.width = 800;  // Logical canvas size
            canvas.height = 600;
            
            // Set display size
            canvas.style.width = `${newWidth}px`;
            canvas.style.height = `${newHeight}px`;
            
            // Adjust game objects scale
            const scaleX = canvas.width / newWidth;
            const scaleY = canvas.height / newHeight;
            
            // Recalculate game object positions if needed
            paddle.x *= scaleX;
            ball.x *= scaleX;
            ball.y *= scaleY;
        }

        // Add orientation change listener
        window.addEventListener('orientationchange', resizeCanvas);

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver) return;
            
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                keys.right = true;
            }
            if (e.key === 'Left' || e.key === 'ArrowLeft') {
                keys.left = true;
            }
            if (e.key === 'p' || e.key === 'P') togglePause();
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'Right' || e.key === 'ArrowRight') {
                keys.right = false;
            }
            if (e.key === 'Left' || e.key === 'ArrowLeft') {
                keys.left = false;
            }
        });

        // Touch controls
        function handleTouchStart(e) {
            e.preventDefault();
            if (gameState.gameOver) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const touchX = (touch.clientX - rect.left) * scaleX;
            
            // Check for double-tap to start/pause
            const currentTime = new Date().getTime();
            if (this.lastTapTime && (currentTime - this.lastTapTime) < 300) {
                togglePause();
                this.lastTapTime = null;
                return;
            }
            this.lastTapTime = currentTime;
            
            // Divide screen into thirds
            const screenThird = canvas.width / 3;
            
            // Left third: move left
            if (touchX < screenThird) {
                keys.left = true;
                keys.right = false;
            } 
            // Right third: move right
            else if (touchX > 2 * screenThird) {
                keys.right = true;
                keys.left = false;
            } 
            // Middle third: start/pause or do nothing
            else {
                // Optional: you could add a specific action for middle third
                keys.left = false;
                keys.right = false;
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (gameState.gameOver) return;
            
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const touchX = (touch.clientX - rect.left) * scaleX;
            
            // Divide screen into thirds
            const screenThird = canvas.width / 3;
            
            // Left third: move left
            if (touchX < screenThird) {
                keys.left = true;
                keys.right = false;
            } 
            // Right third: move right
            else if (touchX > 2 * screenThird) {
                keys.right = true;
                keys.left = false;
            } 
            // Middle third: stop movement
            else {
                keys.left = false;
                keys.right = false;
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            keys.left = false;
            keys.right = false;
        }

        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);
        
        // Prevent default touch behaviors
        canvas.addEventListener('touchcancel', (e) => e.preventDefault());
        document.body.addEventListener('touchmove', (e) => {
            if (e.target === canvas) {
                e.preventDefault();
            }
        }, { passive: false });

        // Pause functionality
        pauseButton.addEventListener('click', togglePause);

        function togglePause() {
            if (gameState.gameOver) {
                restartGame();
                return;
            }

            gameState.paused = !gameState.paused;

            if (!gameState.gameStarted) {
                // First time starting the game or a new level
                gameState.gameStarted = true;
                gameState.paused = false;
                
                // Set initial ball movement based on current level
                const currentLevel = LEVELS[gameState.level - 1];
                ball.speedX = currentLevel.ballSpeed * (Math.random() > 0.5 ? 1 : -1);
                ball.speedY = -currentLevel.ballSpeed;
                
                pauseButton.textContent = 'Pause';
            } else {
                // Regular pause/resume
                pauseButton.textContent = gameState.paused ? 'Resume' : 'Pause';
            }
        }

        // Sound system
        const sounds = {
            paddleHit: document.getElementById('paddleHitSound'),
            blockBreak: document.getElementById('blockBreakSound'),
            lifeGain: document.getElementById('lifeGainSound'),
            lifeLoss: document.getElementById('lifeLossSound')
        };

        function playSound(soundId) {
            const sound = sounds[soundId];
            if (sound) {
                sound.currentTime = 0;  // Reset the sound to start
                sound.play().catch(e => console.log('Error playing sound:', e));
            }
        }

        // Update game state
        function update() {
            if (gameState.paused || gameState.gameOver) return;

            // Move paddle based on input state
            if (keys.left) {
                paddle.x -= paddle.speed;
            }
            if (keys.right) {
                paddle.x += paddle.speed;
            }
            
            // Keep paddle within bounds
            paddle.x = Math.max(paddle.width/2, Math.min(canvas.width - paddle.width/2, paddle.x));

            // Update power-ups
            updatePowerUps();

            // Update particles
            updateParticles();

            // Move ball
            ball.x += ball.speedX;
            ball.y += ball.speedY;

            // Wall collisions
            if (ball.x <= 0 || ball.x >= canvas.width - ball.size) {
                ball.speedX *= -1;
            }
            if (ball.y <= 0) {
                ball.speedY *= -1;
            }

            // Paddle collision
            if (ball.y + ball.size >= paddle.y &&
                ball.x >= paddle.x - paddle.width/2 &&
                ball.x <= paddle.x + paddle.width/2) {
                ball.speedY = -Math.abs(ball.speedY);
                let hitPos = (ball.x - paddle.x) / (paddle.width/2);
                ball.speedX = hitPos * 8;
                playSound('paddleHit');
            }

            // Block collisions
            blocks.forEach((block, index) => {
                if (ball.x + ball.size >= block.x &&
                    ball.x <= block.x + block.width &&
                    ball.y + ball.size >= block.y &&
                    ball.y <= block.y + block.height) {
                    
                    ball.speedY *= -1;
                    handleBlockCollision(block, index);
                    playSound('blockBreak');
                }
            });

            // Level complete
            if (blocks.length === 0) {
                console.log(`Level ${gameState.level} complete`);
                
                if (gameState.level < LEVELS.length) {
                    gameState.level++;
                    levelElement.textContent = `Level: ${gameState.level}`;
                    
                    const level = LEVELS[gameState.level - 1];
                    
                    // Reset paddle width
                    paddle.width = level.paddleWidth;
                    paddle.x = canvas.width / 2 - paddle.width / 2;
                    
                    // Reset ball speed and direction
                    ball.speedX = level.ballSpeed * (Math.random() > 0.5 ? 1 : -1);
                    ball.speedY = -level.ballSpeed;
                    
                    // Recreate blocks for new level
                    blocks = [];
                    createBlocks();
                    
                    // Reset ball position
                    ball.x = paddle.x + paddle.width / 2;
                    ball.y = paddle.y - ball.size;
                    
                    // Pause game to allow player to prepare
                    gameState.paused = true;
                    pauseButton.textContent = 'Start';
                    
                    console.log(`Initialized level ${gameState.level}`);
                } else {
                    // Game completed
                    showGameOver('Congratulations! You Won!');
                }
            }

            // Ball falls below paddle
            if (ball.y > canvas.height) {
                gameState.lives--;
                livesElement.textContent = `Lives: ${gameState.lives}`;
                if (gameState.lives > 0) {
                    resetBall();
                } else {
                    showGameOver('Game Over');
                }
            }
        }

        // Draw game objects
        function draw() {
            // Clear canvas with gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#1a1a1a');
            gradient.addColorStop(1, '#000000');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw particles
            drawParticles();

            // Draw paddle with gradient
            const paddleGradient = ctx.createLinearGradient(
                paddle.x - paddle.width/2,
                paddle.y,
                paddle.x - paddle.width/2,
                paddle.y + paddle.height
            );
            paddleGradient.addColorStop(0, '#ffffff');
            paddleGradient.addColorStop(1, '#999999');
            ctx.fillStyle = paddleGradient;
            ctx.fillRect(paddle.x - paddle.width/2, paddle.y, paddle.width, paddle.height);

            // Draw ball with gradient
            const ballGradient = ctx.createRadialGradient(
                ball.x, ball.y, 0,
                ball.x, ball.y, ball.size
            );
            ballGradient.addColorStop(0, '#ffffff');
            ballGradient.addColorStop(1, '#cccccc');
            ctx.fillStyle = ballGradient;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.size, 0, Math.PI * 2);
            ctx.fill();

            // Draw blocks with gradients
            drawBlocks();

            // Draw power-ups
            drawPowerUps();
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        function showGameOver(message) {
            const gameOverScreen = document.getElementById('gameOverScreen');
            const gameOverTitle = document.getElementById('gameOverTitle');
            const gameOverScore = document.getElementById('gameOverScore');
            
            gameOverTitle.textContent = message;
            gameOverScore.textContent = `Final Score: ${gameState.score}`;
            gameOverScreen.style.display = 'block';
            gameState.gameOver = true;
        }

        function restartGame() {
            document.getElementById('gameOverScreen').style.display = 'none';
            gameState = {
                level: 1,
                score: 0,
                lives: 3,
                paused: false,
                gameStarted: false,
                gameOver: false
            };
            levelElement.textContent = `Level: ${gameState.level}`;
            scoreElement.textContent = `Score: ${gameState.score}`;
            livesElement.textContent = `Lives: ${gameState.lives}`;
            paddle.width = LEVELS[0].paddleWidth;
            createBlocks();
            resetBall();
            powerUps = [];  // Clear any existing power-ups
        }

        // Settings functionality
        const settingsButton = document.getElementById('settingsButton');
        const settingsMenu = document.getElementById('settingsMenu');
        const rulesContent = document.getElementById('rulesContent');
        const levelSelect = document.getElementById('levelSelect');

        // Populate level select
        for (let i = 1; i <= LEVELS.length; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = `Level ${i}`;
            levelSelect.appendChild(option);
        }

        settingsButton.addEventListener('click', () => {
            const isVisible = settingsMenu.style.display === 'block';
            settingsMenu.style.display = isVisible ? 'none' : 'block';
            document.getElementById('modalOverlay').style.display = isVisible ? 'none' : 'block';
            gameState.paused = !isVisible;
            pauseButton.textContent = isVisible ? 'Pause' : 'Resume';
        });

        function closeSettings() {
            settingsMenu.style.display = 'none';
            document.getElementById('modalOverlay').style.display = 'none';
            if (!document.getElementById('rulesModal').style.display === 'block') {
                gameState.paused = false;
                pauseButton.textContent = 'Pause';
            }
        }

        function toggleRules() {
            rulesContent.style.display = rulesContent.style.display === 'none' ? 'block' : 'none';
        }

        function skipToLevel(level) {
            console.log('Attempting to skip to level:', level);
            
            // Basic validation
            level = parseInt(level);
            if (isNaN(level) || level < 1 || level > LEVELS.length) {
                console.error('Invalid level:', level);
                return;
            }

            // Reset core game state
            gameState.level = level;
            gameState.score = 0;
            gameState.lives = 3;
            gameState.paused = true;  // Pause to give player control
            gameState.gameStarted = false;

            // Clear existing game objects
            blocks = [];
            powerUps = [];
            particles = [];

            // Recreate blocks
            createBlocks();

            // Reset ball and paddle
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.width = LEVELS[level - 1].paddleWidth;

            ball.x = paddle.x + paddle.width / 2;
            ball.y = paddle.y - ball.size;
            ball.speedX = 0;
            ball.speedY = 0;

            // Update UI
            levelElement.textContent = `Level: ${gameState.level}`;
            scoreElement.textContent = `Score: 0`;
            livesElement.textContent = `Lives: 3`;
            pauseButton.textContent = 'Start';  // Indicate game is ready to start
        }

        // Modify togglePause to handle game start and resume
        function togglePause() {
            if (gameState.gameOver) {
                restartGame();
                return;
            }

            gameState.paused = !gameState.paused;

            if (!gameState.gameStarted) {
                // First time starting the game or a new level
                gameState.gameStarted = true;
                gameState.paused = false;
                
                // Set initial ball movement based on current level
                const currentLevel = LEVELS[gameState.level - 1];
                ball.speedX = currentLevel.ballSpeed * (Math.random() > 0.5 ? 1 : -1);
                ball.speedY = -currentLevel.ballSpeed;
                
                pauseButton.textContent = 'Pause';
            } else {
                // Regular pause/resume
                pauseButton.textContent = gameState.paused ? 'Resume' : 'Pause';
            }
        }

        // Modify initGame to set initial state
        function initGame() {
            console.log('Initializing game...');
            
            // Ensure critical elements exist
            if (!canvas || !ctx) {
                console.error('Canvas not initialized');
                return;
            }

            // Reset game state
            gameState.level = 1;
            gameState.score = 0;
            gameState.lives = 3;
            gameState.paused = true;
            gameState.gameStarted = false;
            gameState.gameOver = false;

            // Initialize game objects
            blocks = [];
            powerUps = [];
            particles = [];

            // Create initial blocks
            createBlocks();

            // Reset ball and paddle
            paddle.x = canvas.width / 2 - paddle.width / 2;
            paddle.width = LEVELS[0].paddleWidth;

            ball.x = paddle.x + paddle.width / 2;
            ball.y = paddle.y - ball.size;
            ball.speedX = 0;
            ball.speedY = 0;

            // Update UI
            levelElement.textContent = `Level: 1`;
            scoreElement.textContent = `Score: 0`;
            livesElement.textContent = `Lives: 3`;
            pauseButton.textContent = 'Start';

            // Start game loop
            gameLoop();
        }

        // Attach event listener to level select
        document.getElementById('levelSelect').addEventListener('change', function() {
            const selectedLevel = this.value;
            if (selectedLevel) {
                skipToLevel(selectedLevel);
            }
        });

        // Rules and settings functions
        function showRules() {
            settingsMenu.style.display = 'none';  // Hide settings menu
            const rulesModal = document.getElementById('rulesModal');
            const modalOverlay = document.getElementById('modalOverlay');
            
            if (rulesModal && modalOverlay) {
                rulesModal.style.display = 'block';
                modalOverlay.style.display = 'block';
                gameState.paused = true;
                pauseButton.textContent = 'Resume';
            } else {
                console.error('Rules modal elements not found');
            }
        }

        function closeRules() {
            const rulesModal = document.getElementById('rulesModal');
            const modalOverlay = document.getElementById('modalOverlay');
            
            if (rulesModal && modalOverlay) {
                rulesModal.style.display = 'none';
                modalOverlay.style.display = 'none';
                gameState.paused = false;
                pauseButton.textContent = 'Pause';
            }
        }

        function toggleRules() {
            const rulesModal = document.getElementById('rulesModal');
            if (rulesModal.style.display === 'block') {
                closeRules();
            } else {
                showRules();
            }
        }

        function backToSettings() {
            const rulesModal = document.getElementById('rulesModal');
            const settingsMenu = document.getElementById('settingsMenu');
            
            if (rulesModal && settingsMenu) {
                rulesModal.style.display = 'none';
                settingsMenu.style.display = 'block';
            }
        }

        // Close modals when clicking overlay
        const modalOverlay = document.getElementById('modalOverlay');
        if (modalOverlay) {
            modalOverlay.addEventListener('click', () => {
                closeRules();
                const settingsMenu = document.getElementById('settingsMenu');
                if (settingsMenu) {
                    settingsMenu.style.display = 'none';
                }
            });
        }

        // Attach event listeners to rules-related buttons
        const rulesButton = document.getElementById('rulesButton');
        if (rulesButton) {
            rulesButton.addEventListener('click', showRules);
        }

        const closeRulesButton = document.getElementById('closeRulesButton');
        if (closeRulesButton) {
            closeRulesButton.addEventListener('click', closeRules);
        }

        const backToSettingsButton = document.getElementById('backToSettingsButton');
        if (backToSettingsButton) {
            backToSettingsButton.addEventListener('click', backToSettings);
        }

        // Initialize game when document loads
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
